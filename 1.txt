So I have vault contracts and a vrf strategy etc etc in my contracts, that I want to expand on and move over to etherlink testnet. My agents purpose is to use the ML risk assessment module to interact with the vault, and optimally move funds across different strategies and use it to generate a yield, even using layerzero bridge to bridge the funds when neccessary and use defi strategies on another chain? And i later also want to add a MEV aspect that sandwiches and frontruns.

Here are my old contracts to adjust and build upon to complete the contract side of this project on etherlink:

contracts:

autodepositproxy:

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import {Vault} from "./Vault.sol";

/// @title AutoDepositProxy
/// @notice A proxy contract that automatically deposits received USDC into a vault
/// @dev This allows funds to be sent directly to this contract, which auto-deposits to the vault.
contract AutoDepositProxy {
    using SafeERC20 for IERC20;

    /// @notice The target vault for deposits
    Vault public immutable vault;

    /// @notice The USDC token
    IERC20 public immutable usdc;

    /// @notice Address that should receive the vault shares
    address public immutable beneficiary;

    event AutoDeposit(address indexed beneficiary, uint256 usdcAmount, uint256 sharesReceived);

    constructor(address _vault, address _usdc, address _beneficiary) {
        vault = Vault(_vault);
        usdc = IERC20(_usdc);
        beneficiary = _beneficiary;

        // Pre-approve vault to save gas on deposits.
        // Changed from safeApprove to approve for OpenZeppelin v5 compatibility.
        usdc.approve(_vault, type(uint256).max);
    }

    /// @notice Automatically deposit any USDC balance to the vault.
    /// @dev Can be called by anyone; sends vault shares to the beneficiary.
    function autoDeposit() public {
        uint256 balance = usdc.balanceOf(address(this));
        if (balance > 0) {
            // The vault's deposit function will pull the funds from this proxy contract.
            // The approval for this is given in the constructor.
            uint256 shares = vault.deposit(balance, beneficiary);
            emit AutoDeposit(beneficiary, balance, shares);
        }
    }

    /// @notice Fallback function that triggers auto-deposit when this contract is called.
    /// @dev This allows the contract to automatically deposit when USDC arrives from a bridge.
    fallback() external {
        autoDeposit();
    }

    receive() external payable {
        // This contract is not meant to hold ETH.
    }
}


flowvrfstrategy:
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
// This import path has been updated for OpenZeppelin v5
import {ReentrancyGuard} from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "./interfaces/Strategies.sol";

/// @title FlowVrfYieldStrategy
/// @notice A strategy that collects deposits and uses yield from another source (e.g., Aave) to fund a no-loss lottery. The winner is chosen using Flow's native VRF.
/// @dev This contract showcases integration with Flow's native randomness feature.
contract FlowVrfYieldStrategy is IStrategies, ReentrancyGuard {
    using SafeERC20 for IERC20;

    /// @notice Address of the Flow's Cadence Arch contract for VRF
    address constant public CADENCE_ARCH = 0x0000000000000000000000010000000000000001;

    address public immutable vault;
    // Changed from public to internal to resolve function signature conflict
    IERC20 internal immutable _underlyingToken;
    address public immutable yieldSource; // e.g., an Aave or Compound strategy contract

    address[] public depositors;
    mapping(address => uint256) public depositAmounts;
    uint256 public totalDeposited;
    address public lastWinner;
    bool public paused;

    event YieldDeposited(uint256 amount);
    event WinnerAwarded(address indexed winner, uint256 amount);

    constructor(address _vault, address _underlying, address _yieldSource) {
        vault = _vault;
        _underlyingToken = IERC20(_underlying);
        yieldSource = _yieldSource;
    }

    function execute(uint256 amount, bytes calldata data) external override nonReentrant {
        require(msg.sender == vault, "Only vault can execute");
        require(!paused, "Strategy is paused");
        require(amount > 0, "Amount must be positive");

        if (depositAmounts[tx.origin] == 0) {
            depositors.push(tx.origin);
        }
        depositAmounts[tx.origin] += amount;
        totalDeposited += amount;
        
        emit Deposit(amount);
    }

    function depositYield(uint256 yieldAmount) external nonReentrant {
        require(yieldAmount > 0, "Yield must be positive");
        _underlyingToken.safeTransferFrom(msg.sender, address(this), yieldAmount);
        emit YieldDeposited(yieldAmount);
    }
    
    function harvest(bytes calldata data) external override nonReentrant {
        require(msg.sender == vault, "Only vault can call harvest");
        uint256 yieldBalance = _underlyingToken.balanceOf(address(this)) - totalDeposited;

        if (yieldBalance > 0 && depositors.length > 0) {
            address winner = _pickWinner();
            lastWinner = winner;
            
            _underlyingToken.safeTransfer(winner, yieldBalance);
            emit WinnerAwarded(winner, yieldBalance);
        }
        emit Harvested(data);
    }

    function _pickWinner() internal view returns (address) {
        (bool ok, bytes memory data) = CADENCE_ARCH.staticcall(
            abi.encodeWithSignature("revertibleRandom()")
        );
        require(ok, "Failed to fetch random number from Flow VRF");
        
        uint64 randomNumber = abi.decode(data, (uint64));
        
        uint256 winnerIndex = randomNumber % depositors.length;
        return depositors[winnerIndex];
    }
    
    function emergencyExit(bytes calldata data) external override {
        require(msg.sender == vault, "Only vault can exit");
        uint256 balance = _underlyingToken.balanceOf(address(this));
        if (balance > 0) {
            _underlyingToken.safeTransfer(vault, balance);
        }
        emit EmergencyExited(balance, data);
    }

    function getBalance() public view override returns (uint256) {
        return _underlyingToken.balanceOf(address(this));
    }

    // --- Interface Compliance ---
    
    function underlyingToken() external view override returns (address) { 
        return address(_underlyingToken); 
    }

    // NOTE: The explicit `paused()` function was removed.
    // The `bool public paused;` state variable automatically creates a public getter.

    function knownRewardTokens(address token) external view override returns (bool) {
        return token == address(_underlyingToken);
    }

    function rewardTokensList() external view override returns (address[] memory) {
        address[] memory tokens = new address[](1);
        tokens[0] = address(_underlyingToken);
        return tokens;
    }

    function setPaused(bool _paused) external override {
        // In a real implementation, this should be restricted (e.g., onlyAgent)
        require(msg.sender == vault, "Only vault can set pause");
        paused = _paused;
    }

    // --- Unused Functions for this Strategy ---
    function protocol() external pure override returns (address) { return address(0); }
    function depositSelector() external pure override returns (bytes4) { return bytes4(0); }
    function withdrawSelector() external pure override returns (bytes4) { return bytes4(0); }
    function claimSelector() external pure override returns (bytes4) { return bytes4(0); }
    function getBalanceSelector() external pure override returns (bytes4) { return bytes4(0); }
    function setVault(address _vault) external override {}
    function addRewardToken(address tokenAddress) external override {}
    function claimRewards(bytes calldata data) external override {}
    function queryProtocol(bytes4 selector, bytes calldata params) external view override returns (bytes memory) { return ""; }
}

vault.sol:
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import {Math} from "@openzeppelin/contracts/utils/math/Math.sol";
import {ReentrancyGuard} from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import {AccessControl} from "@openzeppelin/contracts/access/AccessControl.sol";
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {IERC4626} from "@openzeppelin/contracts/interfaces/IERC4626.sol";
import "./interfaces/Strategies.sol";

/// @title Vault Contract for Flow (OpenZeppelin v5 Compatible)
/// @notice An ERC4626-compliant vault that manages deposits and allocates them to yield strategies.
/// @dev Implements the IERC4626 interface from scratch.
contract Vault is Ownable, ERC20, AccessControl, ReentrancyGuard, IERC4626 {
    using SafeERC20 for IERC20;

    // --- Roles ---
    bytes32 public constant MANAGER_ROLE = keccak256("MANAGER_ROLE");
    bytes32 public constant AGENT_ROLE = keccak256("AGENT_ROLE");

    // --- State Variables ---
    IERC20 private immutable _asset;
    address[] public strategies;
    mapping(address => bool) public isStrategy;

    // --- Events ---
    event StrategyAdded(address indexed strategy);
    event StrategyRemoved(address indexed strategy);
    event StrategyExecuted(address indexed strategy, uint256 amount, bytes data);
    event StrategyHarvested(address indexed strategy, bytes data);

    // --- Errors ---
    error InvalidStrategy();
    error StrategyAlreadyExists();
    error StrategyDoesNotExist();
    error ExecutionFailed();
    error InvalidAddress();
    error InsufficientBalance();

    // --- Modifiers ---
    modifier onlyManager() {
        require(hasRole(MANAGER_ROLE, msg.sender), "Vault: caller is not a manager");
        _;
    }

    modifier onlyAgent() {
        require(hasRole(AGENT_ROLE, msg.sender), "Vault: caller is not an agent");
        _;
    }

    constructor(
        IERC20 assetToken,
        string memory name,
        string memory symbol,
        address _manager,
        address _agent
    ) ERC20(name, symbol) Ownable(msg.sender) {
        require(address(assetToken) != address(0), "Vault: asset is zero address");
        require(_manager != address(0), "Vault: manager is zero address");
        require(_agent != address(0), "Vault: agent is zero address");

        _asset = assetToken;

        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setRoleAdmin(MANAGER_ROLE, DEFAULT_ADMIN_ROLE);
        _setRoleAdmin(AGENT_ROLE, DEFAULT_ADMIN_ROLE);

        _grantRole(MANAGER_ROLE, _manager);
        _grantRole(AGENT_ROLE, _agent);
    }

    // ========================================================
    // ERC4626 IMPLEMENTATION
    // ========================================================

    /** @dev See {IERC4626-asset}. */
    function asset() public view virtual override returns (address) {
        return address(_asset);
    }

    /** @dev See {IERC4626-totalAssets}. */
    function totalAssets() public view virtual override returns (uint256) {
        uint256 assetsInStrategies = 0;
        for (uint i = 0; i < strategies.length; i++) {
            assetsInStrategies += IStrategies(strategies[i]).getBalance();
        }
        return _asset.balanceOf(address(this)) + assetsInStrategies;
    }

    /** @dev See {IERC4626-convertToShares}. */
    function convertToShares(uint256 assetsValue) public view virtual override returns (uint256) {
        return _convertToShares(assetsValue, Math.Rounding(0)); // Down
    }

    /** @dev See {IERC4626-convertToAssets}. */
    function convertToAssets(uint256 sharesValue) public view virtual override returns (uint256) {
        return _convertToAssets(sharesValue, Math.Rounding(0)); // Down
    }

    /** @dev See {IERC4626-maxDeposit}. */
    function maxDeposit(address) public view virtual override returns (uint256) {
        return type(uint256).max;
    }

    /** @dev See {IERC4626-previewDeposit}. */
    function previewDeposit(uint256 assetsValue) public view virtual override returns (uint256) {
        return _convertToShares(assetsValue, Math.Rounding(0)); // Down
    }

    /** @dev See {IERC4626-deposit}. */
    function deposit(uint256 assetsValue, address receiver) public virtual override nonReentrant returns (uint256 shares) {
        shares = previewDeposit(assetsValue);
        _deposit(assetsValue, shares, receiver);
        return shares;
    }

    /** @dev See {IERC4626-maxMint}. */
    function maxMint(address) public view virtual override returns (uint256) {
        return type(uint256).max;
    }

    /** @dev See {IERC4626-previewMint}. */
    function previewMint(uint256 sharesValue) public view virtual override returns (uint256) {
        return _convertToAssets(sharesValue, Math.Rounding(1)); // Up
    }

    /** @dev See {IERC4626-mint}. */
    function mint(uint256 sharesValue, address receiver) public virtual override nonReentrant returns (uint256 assets) {
        assets = previewMint(sharesValue);
        _deposit(assets, sharesValue, receiver);
        return assets;
    }

    /** @dev See {IERC4626-maxWithdraw}. */
    function maxWithdraw(address owner) public view virtual override returns (uint256) {
        return _convertToAssets(balanceOf(owner), Math.Rounding(0)); // Down
    }

    /** @dev See {IERC4626-previewWithdraw}. */
    function previewWithdraw(uint256 assetsValue) public view virtual override returns (uint256) {
        return _convertToShares(assetsValue, Math.Rounding(1)); // Up
    }

    /** @dev See {IERC4626-withdraw}. */
    function withdraw(uint256 assetsValue, address receiver, address owner) public virtual override nonReentrant returns (uint256 shares) {
        shares = previewWithdraw(assetsValue);
        _withdraw(assetsValue, shares, receiver, owner);
        return shares;
    }

    /** @dev See {IERC4626-maxRedeem}. */
    function maxRedeem(address owner) public view virtual override returns (uint256) {
        return balanceOf(owner);
    }

    /** @dev See {IERC4626-previewRedeem}. */
    function previewRedeem(uint256 sharesValue) public view virtual override returns (uint256) {
        return _convertToAssets(sharesValue, Math.Rounding(0)); // Down
    }

    /** @dev See {IERC4626-redeem}. */
    function redeem(uint256 sharesValue, address receiver, address owner) public virtual override nonReentrant returns (uint256 assets) {
        assets = previewRedeem(sharesValue);
        _withdraw(assets, sharesValue, receiver, owner);
        return assets;
    }

    // ========================================================
    // INTERNAL LOGIC
    // ========================================================

    function _deposit(uint256 assetsValue, uint256 sharesValue, address receiver) internal {
        require(receiver != address(0), "Vault: deposit to the zero address");
        require(assetsValue > 0, "Vault: deposit of zero assets");

        _asset.safeTransferFrom(msg.sender, address(this), assetsValue);
        _mint(receiver, sharesValue);
        emit Deposit(msg.sender, receiver, assetsValue, sharesValue);
    }

    function _withdraw(uint256 assetsValue, uint256 sharesValue, address receiver, address owner) internal {
        require(receiver != address(0), "Vault: withdraw to the zero address");
        require(assetsValue > 0, "Vault: withdraw of zero assets");

        if (msg.sender != owner) {
            _spendAllowance(owner, msg.sender, sharesValue);
        }

        _burn(owner, sharesValue);
        _asset.safeTransfer(receiver, assetsValue);
        emit Withdraw(msg.sender, receiver, owner, assetsValue, sharesValue);
    }

    function _convertToShares(uint256 assetsValue, Math.Rounding rounding) internal view returns (uint256) {
        uint256 supply = totalSupply();
        return (supply == 0)
            ? assetsValue
            : Math.mulDiv(assetsValue, supply, totalAssets(), rounding);
    }

    function _convertToAssets(uint256 sharesValue, Math.Rounding rounding) internal view returns (uint256) {
        uint256 supply = totalSupply();
        return (supply == 0)
            ? sharesValue
            : Math.mulDiv(sharesValue, totalAssets(), supply, rounding);
    }


    // ========================================================
    // STRATEGY MANAGEMENT
    // ========================================================

    function addStrategy(address _strategy) external onlyManager {
        if (_strategy == address(0)) revert InvalidAddress();
        if (isStrategy[_strategy]) revert StrategyAlreadyExists();

        isStrategy[_strategy] = true;
        strategies.push(_strategy);
        emit StrategyAdded(_strategy);
    }

    function removeStrategy(address _strategy) external onlyManager {
        if (!isStrategy[_strategy]) revert StrategyDoesNotExist();
        isStrategy[_strategy] = false;

        for (uint256 i = 0; i < strategies.length; i++) {
            if (strategies[i] == _strategy) {
                strategies[i] = strategies[strategies.length - 1];
                strategies.pop();
                break;
            }
        }
        emit StrategyRemoved(_strategy);
    }

    function depositToStrategy(
        address _strategy,
        uint256 _amount,
        bytes calldata _data
    ) external onlyAgent nonReentrant {
        if (!isStrategy[_strategy]) revert StrategyDoesNotExist();
        if (_asset.balanceOf(address(this)) < _amount) revert InsufficientBalance();

        // Changed from safeApprove to the standard approve for OZ v5 compatibility
        _asset.approve(_strategy, _amount);
        IStrategies(_strategy).execute(_amount, _data);
        emit StrategyExecuted(_strategy, _amount, _data);
    }
    
    function harvestStrategy(
        address _strategy,
        bytes calldata _data
    ) external onlyAgent nonReentrant {
        if (!isStrategy[_strategy]) revert StrategyDoesNotExist();

        IStrategies(_strategy).harvest(_data);
        emit StrategyHarvested(_strategy, _data);
    }

    function getStrategies() external view returns (address[] memory) {
        return strategies;
    }
}

vaultfactory:

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "./Vault.sol";

/// @title VaultFactory Contract for Flow
/// @notice Factory contract for creating and managing Vault instances on Flow.
/// @dev Implements access control for vault creation and management.
contract VaultFactory is Ownable {
    uint256 public vaultCounter;
    mapping(uint256 => address) public vaults;

    address public defaultManager;
    address public defaultAgent;
    uint256 public creationFee;
    address public treasury;

    struct VaultParams {
        IERC20 asset;
        string name;
        string symbol;
        address manager;
        address agent;
    }

    event VaultCreated(
        uint256 indexed vaultId,
        address indexed vaultAddress,
        address indexed asset,
        address creator
    );

    error InvalidAsset();
    error InsufficientFee();

    constructor(
        address _defaultManager,
        address _defaultAgent,
        address _treasury,
        uint256 _creationFee
    ) Ownable(msg.sender) {
        defaultManager = _defaultManager;
        defaultAgent = _defaultAgent;
        treasury = _treasury;
        creationFee = _creationFee;
    }

    function createVault(
        VaultParams calldata params
    ) external payable returns (address vaultAddress, uint256 vaultId) {
        if (address(params.asset) == address(0)) revert InvalidAsset();
        if (msg.value < creationFee) revert InsufficientFee();

        address manager = params.manager != address(0) ? params.manager : defaultManager;
        address agent = params.agent != address(0) ? params.agent : defaultAgent;

        vaultCounter++;
        vaultId = vaultCounter;

        // Note: The deBridgeGate parameter has been removed for Flow-specific deployment.
        Vault vault = new Vault(
            params.asset,
            params.name,
            params.symbol,
            manager,
            agent
        );

        vaultAddress = address(vault);
        vaults[vaultId] = vaultAddress;

        if (creationFee > 0) {
            (bool success, ) = treasury.call{value: creationFee}("");
            require(success, "Fee transfer failed");
        }

        emit VaultCreated(vaultId, vaultAddress, address(params.asset), msg.sender);
        return (vaultAddress, vaultId);
    }

    function getVaultCount() external view returns (uint256) {
        return vaultCounter;
    }

    // --- Admin Functions ---
    function setTreasury(address _newTreasury) external onlyOwner {
        treasury = _newTreasury;
    }

    function setCreationFee(uint256 _newFee) external onlyOwner {
        creationFee = _newFee;
    }
}

contracts/strategies strategies.sol:
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";

/**
 * @title GenericStrategyImplementation
 * @dev Implementation of the IStrategy interface that can interact with any protocol via function selectors
 * @notice This is a completely generic implementation that can be reused for any protocol
 * @custom:security-contact security@vaults.com
 */
contract Strategies is ReentrancyGuard {
    using SafeERC20 for IERC20;

    // State variables - immutable for gas optimization
    address public immutable underlyingToken;
    address public immutable protocol;
    bytes4 public immutable depositSelector;
    bytes4 public immutable withdrawSelector;
    bytes4 public immutable claimSelector;
    bytes4 public immutable getBalanceSelector;

    // Mutable state
    address public vault;
    bool public paused;

    // Optional secondary token mappings for rewards
    mapping(address => bool) public knownRewardTokens;
    address[] public rewardTokensList;

    // Events
    event Deposit(uint256 amount);
    event Withdraw(uint256 amount);
    event Claim(uint256 amount);
    event VaultSet(address vault);
    event PausedState(bool isPaused);
    event Executed(uint256 amount, bytes data);
    event Harvested(bytes data);
    event EmergencyExited(uint256 balance, bytes data);
    event RewardTokenAdded(address indexed token);
    event TokensForwarded(address indexed token, uint256 amount);
    event ClaimRewardsFailed(bytes reason);

    // Errors
    error NoVaultSet();
    error StrategyPaused();
    error DepositFailed(bytes reason);
    error WithdrawFailed(bytes reason);
    error ClaimFailed(bytes reason);
    error GetBalanceFailed(bytes reason);
    error NoUnderlyingBalance();
    error InvalidTokenAddress();
    error InvalidAmount();

    // Modifiers
    modifier onlyAgent() {
        if (vault == address(0)) revert NoVaultSet();
        if (msg.sender != vault) {
            revert("Only agent can call");
        }
        _;
    }

    modifier whenNotPaused() {
        if (paused) revert StrategyPaused();
        _;
    }

    /**
     * @dev Constructor for initializing the strategy
     * @param _underlyingToken Address of the underlying token
     * @param _protocol Address of the protocol
     * @param _depositSelector Function selector for deposit
     * @param _withdrawSelector Function selector for withdraw
     * @param _claimSelector Function selector for claim
     * @param _getBalanceSelector Function selector for getBalance
     */
    constructor(
        address _underlyingToken,
        address _protocol,
        bytes4 _depositSelector,
        bytes4 _withdrawSelector,
        bytes4 _claimSelector,
        bytes4 _getBalanceSelector
    ) {
        require(_underlyingToken != address(0), "Invalid token address");
        require(_protocol != address(0), "Invalid protocol address");

        underlyingToken = _underlyingToken;
        protocol = _protocol;
        depositSelector = _depositSelector;
        withdrawSelector = _withdrawSelector;
        claimSelector = _claimSelector;
        getBalanceSelector = _getBalanceSelector;
    }

    /**
     * @dev Sets the vault address
     * @param _vault Address of the vault
     * @notice This can only be set once for security reasons
     */
    function setVault(address _vault) external {
        require(_vault != address(0), "Invalid vault address");
        require(vault == address(0), "Vault already set");
        vault = _vault;
        emit VaultSet(_vault);
    }

    /**
     * @dev Add a known reward token to track
     * @param tokenAddress Address of the reward token
     * @notice This helps the strategy automatically track and forward reward tokens
     */
    function addRewardToken(address tokenAddress) external onlyAgent {
        require(tokenAddress != address(0), "Invalid token address");
        require(!knownRewardTokens[tokenAddress], "Token already added");

        knownRewardTokens[tokenAddress] = true;
        rewardTokensList.push(tokenAddress);
        emit RewardTokenAdded(tokenAddress);
    }

    /**
     * @dev Executes the strategy by depositing tokens into the protocol
     * @param amount Amount of tokens to deposit
     * @param data Additional data needed for the deposit
     * @notice This function handles the transfer of tokens and interaction with the protocol
     */
    function execute(
        uint256 amount,
        bytes calldata data
    ) external onlyAgent nonReentrant whenNotPaused {
        if (amount == 0) revert InvalidAmount();

        // Handle the token transfer first
        IERC20(underlyingToken).safeTransferFrom(vault, address(this), amount);

        // Approve protocol to spend tokens
        uint256 currentAllowance = IERC20(underlyingToken).allowance(
            address(this),
            protocol
        );
        if (currentAllowance < amount) {
            if (currentAllowance > 0) {
                IERC20(underlyingToken).approve(protocol, 0);
            }
            IERC20(underlyingToken).approve(protocol, amount);
        }

        // Use provided data or build default calldata
        bytes memory callData;
        if (data.length > 0) {
            callData = data;
        } else {
            // Default: just use the selector with amount
            callData = abi.encodeWithSelector(depositSelector, amount);
        }

        // Execute the deposit
        (bool success, bytes memory result) = protocol.call(callData);

        if (!success) {
            // Revoke approval for security
            IERC20(underlyingToken).approve(protocol, 0);

            bytes memory revertReason;
            if (result.length > 0) {
                assembly {
                    revertReason := add(result, 0x20)
                }
            }
            revert DepositFailed(revertReason);
        }

        // Forward any reward tokens that might have been received
        _forwardRewardTokens();

        emit Deposit(amount);
        emit Executed(amount, data);
    }

    /**
     * @dev Harvests rewards from the protocol
     * @param data Additional data needed for harvesting
     */
    function harvest(bytes calldata data) external onlyAgent nonReentrant {
        claimRewards(data);
        emit Harvested(data);
    }

    /**
     * @dev Gets the current balance of the strategy in the protocol
     * @return uint256 Balance of the strategy
     * @notice This function retrieves the protocol balance using the provided selector
     */
    function getBalance() public view returns (uint256) {
        if (protocol == address(0) || underlyingToken == address(0)) {
            return 0;
        }

        // Try with address parameter first (most common)
        (bool success, bytes memory result) = protocol.staticcall(
            abi.encodeWithSelector(getBalanceSelector, address(this))
        );

        if (success && result.length >= 32) {
            return abi.decode(result, (uint256));
        }

        // Try without parameters
        (success, result) = protocol.staticcall(
            abi.encodeWithSelector(getBalanceSelector)
        );

        if (success && result.length >= 32) {
            return abi.decode(result, (uint256));
        }

        // Try with token and address parameters
        (success, result) = protocol.staticcall(
            abi.encodeWithSelector(
                getBalanceSelector,
                underlyingToken,
                address(this)
            )
        );

        if (success && result.length >= 32) {
            return abi.decode(result, (uint256));
        }

        return 0;
    }

    /**
     * @dev Performs an emergency exit, withdrawing all funds from the protocol
     * @param data Additional data needed for emergency exit
     */
    function emergencyExit(
        bytes calldata data
    ) external onlyAgent nonReentrant {
        uint256 balance = getBalance();

        if (balance == 0) {
            revert NoUnderlyingBalance();
        }

        // Use provided data or build default calldata
        bytes memory callData;
        if (data.length > 0) {
            callData = data;
        } else {
            // Default: just use the selector with balance
            callData = abi.encodeWithSelector(withdrawSelector, balance);
        }

        // Execute the withdraw
        (bool success, bytes memory result) = protocol.call(callData);

        if (!success) {
            bytes memory revertReason;
            if (result.length > 0) {
                assembly {
                    revertReason := add(result, 0x20)
                }
            }
            revert WithdrawFailed(revertReason);
        }

        // Transfer tokens to the vault
        uint256 tokenBalance = IERC20(underlyingToken).balanceOf(address(this));
        if (tokenBalance > 0) {
            IERC20(underlyingToken).safeTransfer(vault, tokenBalance);
        }

        emit Withdraw(balance);
        emit EmergencyExited(balance, data);
    }

    /**
     * @dev Claims rewards from the protocol
     * @param data Additional data needed for claiming rewards
     */
    function claimRewards(bytes calldata data) public onlyAgent {
        // Skip if claimSelector is not set
        if (claimSelector == bytes4(0)) {
            return;
        }

        // Use provided data or build default calldata
        bytes memory callData;
        if (data.length > 0) {
            callData = data;
        } else {
            // Default: just use the selector
            callData = abi.encodeWithSelector(claimSelector);
        }

        // Execute the claim
        (bool success, bytes memory result) = protocol.call(callData);

        if (!success) {
            bytes memory revertReason;
            if (result.length > 0) {
                assembly {
                    revertReason := add(result, 0x20)
                }
            }
            emit ClaimRewardsFailed(revertReason);
            return;
        }

        // Forward reward tokens
        _forwardRewardTokens();

        emit Claim(0);
    }

    /**
     * @dev Forward all known reward tokens to the vault
     * @notice Gas optimized by avoiding unnecessary operations
     */
    function _forwardRewardTokens() internal {
        uint256 tokenCount = rewardTokensList.length;

        // Limit to avoid gas issues
        uint256 maxTokens = tokenCount > 10 ? 10 : tokenCount;

        for (uint256 i = 0; i < maxTokens; i++) {
            address tokenAddress = rewardTokensList[i];
            uint256 balance = IERC20(tokenAddress).balanceOf(address(this));
            if (balance > 0) {
                IERC20(tokenAddress).safeTransfer(vault, balance);
                emit TokensForwarded(tokenAddress, balance);
            }
        }
    }

    /**
     * @dev Sets the pause state
     * @param _paused New pause state
     */
    function setPaused(bool _paused) external onlyAgent {
        paused = _paused;
        emit PausedState(_paused);
    }

    /**
     * @dev Query the protocol with custom parameters (read-only)
     * @param selector Function selector to call on the protocol
     * @param params Encoded parameters for the function call
     * @return bytes Raw response data from the protocol
     * @notice This function allows querying any view function in the protocol
     */
    function queryProtocol(
        bytes4 selector,
        bytes calldata params
    ) external view returns (bytes memory) {
        require(protocol != address(0), "Protocol not set");

        bytes memory callData = abi.encodePacked(selector, params);
        (bool success, bytes memory result) = protocol.staticcall(callData);

        require(success, "Protocol query failed");
        return result;
    }
}

contracts/strategies/ethereum

compoundV3Strategy:
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/AccessControl.sol";
import "../../interfaces/Strategies.sol";

/// @title ICToken
/// @notice Interface for Compound V3 cTokens
interface ICToken {
    function supply(address asset, uint256 amount) external;
    function withdraw(address asset, uint256 amount) external;
    function balanceOf(address account) external view returns (uint256);
    function baseToken() external view returns (address);
    function getSupplyRate(uint256 utilization) external view returns (uint64);
    function getUtilization() external view returns (uint256);
}

/// @title IComet
/// @notice Interface for Compound V3 Comet
interface IComet {
    function supply(address asset, uint256 amount) external;
    function withdraw(address asset, uint256 amount) external;
    function balanceOf(address account) external view returns (uint256);
    function baseToken() external view returns (address);
    function getSupplyRate(uint256 utilization) external view returns (uint64);
    function getUtilization() external view returns (uint256);
    function accrueAccount(address account) external;
}

/// @title CompoundV3Strategy
/// @notice Strategy for depositing USDC into Compound V3 to earn yield
contract CompoundV3Strategy is IStrategies, ReentrancyGuard, AccessControl {
    using SafeERC20 for IERC20;

    // ============ Constants ============
    
    /// @notice Compound V3 USDC Comet address on Ethereum
    address public constant COMET_USDC = 0xc3d688B66703497DAA19211EEdff47f25384cdc3;
    
    /// @notice USDC token address on Ethereum
    address public constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
    
    /// @notice Role for vault that can execute strategy
    bytes32 public constant VAULT_ROLE = keccak256("VAULT_ROLE");

    // ============ State Variables ============
    
    /// @notice The vault address that owns this strategy
    address public vault;
    
    /// @notice Whether the strategy is paused
    bool public paused;
    
    /// @notice Total amount deposited in Compound
    uint256 public totalDeposited;
    
    /// @notice Last harvest timestamp
    uint256 public lastHarvest;
    
    /// @notice Strategy deployment timestamp
    uint256 public immutable deploymentTime;

    // ============ Errors ============
    
    error OnlyVault();

    // ============ Modifiers ============
    
    modifier onlyVault() {
        if (msg.sender != vault && !hasRole(VAULT_ROLE, msg.sender)) {
            revert OnlyVault();
        }
        _;
    }
    
    modifier whenNotPaused() {
        if (paused) revert IStrategies.StrategyPaused();
        _;
    }

    // ============ Constructor ============
    
    constructor(address _vault) {
        vault = _vault;
        deploymentTime = block.timestamp;
        lastHarvest = block.timestamp;
        
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(VAULT_ROLE, _vault);
        
        // Approve Comet to spend USDC
        IERC20(USDC).approve(COMET_USDC, type(uint256).max);
        
        emit IStrategies.VaultSet(_vault);
    }

    // ============ External Functions ============
    
    /// @inheritdoc IStrategies
    function execute(uint256 amount, bytes calldata data) external onlyVault whenNotPaused nonReentrant {
        if (amount == 0) revert IStrategies.InvalidAmount();
        
        // Transfer USDC from vault
        IERC20(USDC).safeTransferFrom(msg.sender, address(this), amount);
        
        // Supply to Compound V3
        try IComet(COMET_USDC).supply(USDC, amount) {
            totalDeposited += amount;
            emit IStrategies.Deposit(amount);
            emit IStrategies.Executed(amount, data);
        } catch (bytes memory reason) {
            // Return funds to vault on failure
            IERC20(USDC).safeTransfer(msg.sender, amount);
            revert IStrategies.DepositFailed(reason);
        }
    }
    
    /// @inheritdoc IStrategies
    function harvest(bytes calldata data) external onlyVault nonReentrant {
        // Accrue interest first
        IComet(COMET_USDC).accrueAccount(address(this));
        
        uint256 currentBalance = getBalance();
        uint256 earned = currentBalance > totalDeposited ? currentBalance - totalDeposited : 0;
        
        if (earned > 0) {
            // Withdraw earned interest
            try IComet(COMET_USDC).withdraw(USDC, earned) {
                // Transfer earned amount to vault
                IERC20(USDC).safeTransfer(vault, earned);
                
                lastHarvest = block.timestamp;
                emit IStrategies.Claim(earned);
                emit IStrategies.Harvested(data);
            } catch (bytes memory reason) {
                revert IStrategies.ClaimFailed(reason);
            }
        }
    }
    
    /// @inheritdoc IStrategies
    function emergencyExit(bytes calldata data) external onlyVault nonReentrant {
        uint256 balance = getBalance();
        if (balance == 0) revert IStrategies.NoUnderlyingBalance();
        
        try IComet(COMET_USDC).withdraw(USDC, balance) {
            // Transfer all funds to vault
            uint256 withdrawnBalance = IERC20(USDC).balanceOf(address(this));
            IERC20(USDC).safeTransfer(vault, withdrawnBalance);
            
            totalDeposited = 0;
            emit IStrategies.EmergencyExited(withdrawnBalance, data);
        } catch (bytes memory reason) {
            revert IStrategies.WithdrawFailed(reason);
        }
    }
    
    /// @inheritdoc IStrategies
    function claimRewards(bytes calldata data) external onlyVault {
        // Compound V3 doesn't have additional reward tokens for USDC
        // Interest is automatically accrued in comet balance
        IComet(COMET_USDC).accrueAccount(address(this));
        emit IStrategies.Harvested(data);
    }
    
    /// @inheritdoc IStrategies
    function setVault(address _vault) external onlyRole(DEFAULT_ADMIN_ROLE) {
        if (_vault == address(0)) revert IStrategies.InvalidTokenAddress();
        
        vault = _vault;
        _grantRole(VAULT_ROLE, _vault);
        
        emit IStrategies.VaultSet(_vault);
    }
    
    /// @inheritdoc IStrategies
    function setPaused(bool _paused) external onlyRole(DEFAULT_ADMIN_ROLE) {
        paused = _paused;
        emit IStrategies.PausedState(_paused);
    }
    
    /// @inheritdoc IStrategies
    function addRewardToken(address tokenAddress) external onlyRole(DEFAULT_ADMIN_ROLE) {
        // Compound V3 USDC doesn't have additional reward tokens
        // This function exists for interface compliance
        if (tokenAddress == address(0)) revert IStrategies.InvalidTokenAddress();
        // No-op for this strategy
    }

    // ============ View Functions ============
    
    /// @inheritdoc IStrategies
    function underlyingToken() external pure returns (address) {
        return USDC;
    }
    
    /// @inheritdoc IStrategies
    function protocol() external pure returns (address) {
        return COMET_USDC;
    }
    
    /// @inheritdoc IStrategies
    function depositSelector() external pure returns (bytes4) {
        return IComet.supply.selector;
    }
    
    /// @inheritdoc IStrategies
    function withdrawSelector() external pure returns (bytes4) {
        return IComet.withdraw.selector;
    }
    
    /// @inheritdoc IStrategies
    function claimSelector() external pure returns (bytes4) {
        return this.harvest.selector;
    }
    
    /// @inheritdoc IStrategies
    function getBalanceSelector() external pure returns (bytes4) {
        return this.getBalance.selector;
    }
    
    /// @inheritdoc IStrategies
    function getBalance() public view returns (uint256) {
        try IComet(COMET_USDC).balanceOf(address(this)) returns (uint256 balance) {
            return balance;
        } catch {
            revert IStrategies.GetBalanceFailed("");
        }
    }
    
    /// @inheritdoc IStrategies
    function knownRewardTokens(address token) external pure returns (bool) {
        // Compound V3 USDC doesn't have additional reward tokens
        return token == USDC;
    }
    
    /// @inheritdoc IStrategies
    function rewardTokensList() external pure returns (address[] memory) {
        address[] memory tokens = new address[](1);
        tokens[0] = USDC; // Interest earned in USDC
        return tokens;
    }
    
    /// @inheritdoc IStrategies
    function queryProtocol(
        bytes4 selector,
        bytes calldata params
    ) external view returns (bytes memory) {
        if (selector == IComet.getSupplyRate.selector) {
            (uint256 utilization) = abi.decode(params, (uint256));
            try IComet(COMET_USDC).getSupplyRate(utilization) returns (uint64 rate) {
                return abi.encode(rate);
            } catch {
                return "";
            }
        }
        
        if (selector == IComet.getUtilization.selector) {
            try IComet(COMET_USDC).getUtilization() returns (uint256 utilization) {
                return abi.encode(utilization);
            } catch {
                return "";
            }
        }
        
        return "";
    }
    
    /// @notice Get current APY from Compound (approximate)
    /// @return apy Current APY in basis points (e.g., 500 = 5%)
    function getCurrentAPY() external view returns (uint256 apy) {
        if (totalDeposited == 0 || deploymentTime == block.timestamp) {
            return 0;
        }
        
        uint256 currentBalance = getBalance();
        if (currentBalance <= totalDeposited) {
            return 0;
        }
        
        uint256 earned = currentBalance - totalDeposited;
        uint256 timeElapsed = block.timestamp - deploymentTime;
        
        // Calculate annualized return
        // APY = (earned / principal) * (365 days / time elapsed) * 10000 (for basis points)
        apy = (earned * 365 days * 10000) / (totalDeposited * timeElapsed);
    }
    
    /// @notice Get current supply rate from Compound
    /// @return rate Current supply rate per second
    function getCurrentSupplyRate() external view returns (uint64 rate) {
        try IComet(COMET_USDC).getUtilization() returns (uint256 utilization) {
            return IComet(COMET_USDC).getSupplyRate(utilization);
        } catch {
            return 0;
        }
    }
    
    /// @notice Get strategy health metrics
    /// @return healthy Whether strategy is performing well
    /// @return metrics Array of health metrics [APY, utilization, time since last harvest]
    function getHealthMetrics() external view returns (bool healthy, uint256[] memory metrics) {
        metrics = new uint256[](3);
        metrics[0] = this.getCurrentAPY();
        metrics[1] = totalDeposited > 0 ? (getBalance() * 10000) / totalDeposited : 0; // Utilization ratio
        metrics[2] = block.timestamp - lastHarvest; // Time since last harvest
        
        // Strategy is healthy if:
        // 1. APY > 1% (100 basis points)
        // 2. No major losses (utilization > 95%)
        // 3. Harvested within last 7 days
        healthy = metrics[0] > 100 && metrics[1] > 9500 && metrics[2] < 7 days;
    }
}

aavev3strategy:
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/AccessControl.sol";
import "../../interfaces/Strategies.sol";

/// @title IAavePool
/// @notice Interface for Aave V3 Pool
interface IAavePool {
    function supply(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;
    function withdraw(address asset, uint256 amount, address to) external returns (uint256);
    function getUserAccountData(address user) external view returns (
        uint256 totalCollateralBase,
        uint256 totalDebtBase,
        uint256 availableBorrowsBase,
        uint256 currentLiquidationThreshold,
        uint256 ltv,
        uint256 healthFactor
    );
}

/// @title IAToken
/// @notice Interface for Aave aTokens
interface IAToken {
    function balanceOf(address user) external view returns (uint256);
    function UNDERLYING_ASSET_ADDRESS() external view returns (address);
}

/// @title AaveV3Strategy
/// @notice Strategy for depositing USDC into Aave V3 to earn yield
contract AaveV3Strategy is IStrategies, ReentrancyGuard, AccessControl {
    using SafeERC20 for IERC20;

    // ============ Constants ============
    
    /// @notice Aave V3 Pool address on Ethereum
    address public constant AAVE_POOL = 0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2;
    
    /// @notice USDC token address on Ethereum
    address public constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
    
    /// @notice aUSDC token address on Ethereum (Aave V3 USDC)
    address public constant AUSDC = 0x98C23E9d8f34FEFb1B7BD6a91B7FF122F4e16F5c;
    
    /// @notice Role for vault that can execute strategy
    bytes32 public constant VAULT_ROLE = keccak256("VAULT_ROLE");

    // ============ State Variables ============
    
    /// @notice The vault address that owns this strategy
    address public vault;
    
    /// @notice Whether the strategy is paused
    bool public paused;
    
    /// @notice Total amount deposited in Aave
    uint256 public totalDeposited;
    
    /// @notice Last harvest timestamp
    uint256 public lastHarvest;
    
    /// @notice Strategy deployment timestamp
    uint256 public immutable deploymentTime;

    // ============ Errors ============
    
    error OnlyVault();

    // ============ Modifiers ============
    
    modifier onlyVault() {
        if (msg.sender != vault && !hasRole(VAULT_ROLE, msg.sender)) {
            revert OnlyVault();
        }
        _;
    }
    
    modifier whenNotPaused() {
        if (paused) revert IStrategies.StrategyPaused();
        _;
    }

    // ============ Constructor ============
    
    constructor(address _vault) {
        vault = _vault;
        deploymentTime = block.timestamp;
        lastHarvest = block.timestamp;
        
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(VAULT_ROLE, _vault);
        
        // Approve Aave pool to spend USDC
        IERC20(USDC).approve(AAVE_POOL, type(uint256).max);
        
        emit IStrategies.VaultSet(_vault);
    }

    // ============ External Functions ============
    
    /// @inheritdoc IStrategies
    function execute(uint256 amount, bytes calldata data) external onlyVault whenNotPaused nonReentrant {
        if (amount == 0) revert IStrategies.InvalidAmount();
        
        // Transfer USDC from vault
        IERC20(USDC).safeTransferFrom(msg.sender, address(this), amount);
        
        // Supply to Aave V3
        try IAavePool(AAVE_POOL).supply(USDC, amount, address(this), 0) {
            totalDeposited += amount;
            emit IStrategies.Deposit(amount);
            emit IStrategies.Executed(amount, data);
        } catch (bytes memory reason) {
            // Return funds to vault on failure
            IERC20(USDC).safeTransfer(msg.sender, amount);
            revert IStrategies.DepositFailed(reason);
        }
    }
    
    /// @inheritdoc IStrategies
    function harvest(bytes calldata data) external onlyVault nonReentrant {
        uint256 currentBalance = getBalance();
        uint256 earned = currentBalance > totalDeposited ? currentBalance - totalDeposited : 0;
        
        if (earned > 0) {
            // Withdraw earned interest
            try IAavePool(AAVE_POOL).withdraw(USDC, earned, vault) returns (uint256 withdrawn) {
                lastHarvest = block.timestamp;
                emit IStrategies.Claim(withdrawn);
                emit IStrategies.Harvested(data);
            } catch (bytes memory reason) {
                revert IStrategies.ClaimFailed(reason);
            }
        }
    }
    
    /// @inheritdoc IStrategies
    function emergencyExit(bytes calldata data) external onlyVault nonReentrant {
        uint256 balance = getBalance();
        if (balance == 0) revert IStrategies.NoUnderlyingBalance();
        
        try IAavePool(AAVE_POOL).withdraw(USDC, type(uint256).max, vault) returns (uint256 withdrawn) {
            totalDeposited = 0;
            emit IStrategies.EmergencyExited(withdrawn, data);
        } catch (bytes memory reason) {
            revert IStrategies.WithdrawFailed(reason);
        }
    }
    
    /// @inheritdoc IStrategies
    function claimRewards(bytes calldata data) external onlyVault {
        // Aave V3 doesn't have additional reward tokens for USDC
        // Interest is automatically accrued in aToken balance
        emit IStrategies.Harvested(data);
    }
    
    /// @inheritdoc IStrategies
    function setVault(address _vault) external onlyRole(DEFAULT_ADMIN_ROLE) {
        if (_vault == address(0)) revert IStrategies.InvalidTokenAddress();
        
        vault = _vault;
        _grantRole(VAULT_ROLE, _vault);
        
        emit IStrategies.VaultSet(_vault);
    }
    
    /// @inheritdoc IStrategies
    function setPaused(bool _paused) external onlyRole(DEFAULT_ADMIN_ROLE) {
        paused = _paused;
        emit IStrategies.PausedState(_paused);
    }
    
    /// @inheritdoc IStrategies
    function addRewardToken(address tokenAddress) external onlyRole(DEFAULT_ADMIN_ROLE) {
        // Aave V3 USDC doesn't have additional reward tokens
        // This function exists for interface compliance
        if (tokenAddress == address(0)) revert IStrategies.InvalidTokenAddress();
        // No-op for this strategy
    }

    // ============ View Functions ============
    
    /// @inheritdoc IStrategies
    function underlyingToken() external pure returns (address) {
        return USDC;
    }
    
    /// @inheritdoc IStrategies
    function protocol() external pure returns (address) {
        return AAVE_POOL;
    }
    
    /// @inheritdoc IStrategies
    function depositSelector() external pure returns (bytes4) {
        return IAavePool.supply.selector;
    }
    
    /// @inheritdoc IStrategies
    function withdrawSelector() external pure returns (bytes4) {
        return IAavePool.withdraw.selector;
    }
    
    /// @inheritdoc IStrategies
    function claimSelector() external pure returns (bytes4) {
        return this.harvest.selector;
    }
    
    /// @inheritdoc IStrategies
    function getBalanceSelector() external pure returns (bytes4) {
        return this.getBalance.selector;
    }
    
    /// @inheritdoc IStrategies
    function getBalance() public view returns (uint256) {
        try IAToken(AUSDC).balanceOf(address(this)) returns (uint256 balance) {
            return balance;
        } catch {
            revert IStrategies.GetBalanceFailed("");
        }
    }
    
    /// @inheritdoc IStrategies
    function knownRewardTokens(address token) external pure returns (bool) {
        // Aave V3 USDC doesn't have additional reward tokens
        return token == USDC || token == AUSDC;
    }
    
    /// @inheritdoc IStrategies
    function rewardTokensList() external pure returns (address[] memory) {
        address[] memory tokens = new address[](1);
        tokens[0] = USDC; // Interest earned in USDC
        return tokens;
    }
    
    /// @inheritdoc IStrategies
    function queryProtocol(
        bytes4 selector,
        bytes calldata params
    ) external view returns (bytes memory) {
        if (selector == IAavePool.getUserAccountData.selector) {
            (address user) = abi.decode(params, (address));
            try IAavePool(AAVE_POOL).getUserAccountData(user) returns (
                uint256 totalCollateralBase,
                uint256 totalDebtBase,
                uint256 availableBorrowsBase,
                uint256 currentLiquidationThreshold,
                uint256 ltv,
                uint256 healthFactor
            ) {
                return abi.encode(
                    totalCollateralBase,
                    totalDebtBase,
                    availableBorrowsBase,
                    currentLiquidationThreshold,
                    ltv,
                    healthFactor
                );
            } catch {
                return "";
            }
        }
        
        return "";
    }
    
    /// @notice Get current APY from Aave (approximate)
    /// @return apy Current APY in basis points (e.g., 500 = 5%)
    function getCurrentAPY() external view returns (uint256 apy) {
        if (totalDeposited == 0 || deploymentTime == block.timestamp) {
            return 0;
        }
        
        uint256 currentBalance = getBalance();
        if (currentBalance <= totalDeposited) {
            return 0;
        }
        
        uint256 earned = currentBalance - totalDeposited;
        uint256 timeElapsed = block.timestamp - deploymentTime;
        
        // Calculate annualized return
        // APY = (earned / principal) * (365 days / time elapsed) * 10000 (for basis points)
        apy = (earned * 365 days * 10000) / (totalDeposited * timeElapsed);
    }
    
    /// @notice Get strategy health metrics
    /// @return healthy Whether strategy is performing well
    /// @return metrics Array of health metrics [APY, utilization, time since last harvest]
    function getHealthMetrics() external view returns (bool healthy, uint256[] memory metrics) {
        metrics = new uint256[](3);
        metrics[0] = this.getCurrentAPY();
        metrics[1] = totalDeposited > 0 ? (getBalance() * 10000) / totalDeposited : 0; // Utilization ratio
        metrics[2] = block.timestamp - lastHarvest; // Time since last harvest
        
        // Strategy is healthy if:
        // 1. APY > 1% (100 basis points)
        // 2. No major losses (utilization > 95%)
        // 3. Harvested within last 7 days
        healthy = metrics[0] > 100 && metrics[1] > 9500 && metrics[2] < 7 days;
    }
}

contracts/mocks

mockweth:

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

/// @title Mock WETH Token
/// @notice Mock WETH token for testing and Flow deployment
/// @dev Mimics the real WETH token with 18 decimals
contract MockWETH is ERC20, Ownable {
    uint8 private constant DECIMALS = 18;
    uint256 private constant INITIAL_SUPPLY = 120_000_000 * 10 ** DECIMALS; // 120M WETH

    constructor() ERC20("Wrapped Ether", "WETH") Ownable(msg.sender) {
        _mint(msg.sender, INITIAL_SUPPLY);
    }

    function decimals() public pure override returns (uint8) {
        return DECIMALS;
    }

    /// @notice Mint new tokens (only owner)
    /// @param to Address to mint to
    /// @param amount Amount to mint
    function mint(address to, uint256 amount) external onlyOwner {
        _mint(to, amount);
    }

    /// @notice Burn tokens from caller
    /// @param amount Amount to burn
    function burn(uint256 amount) external {
        _burn(msg.sender, amount);
    }

    /// @notice Faucet function for testing (anyone can call)
    /// @param amount Amount to mint to caller (max 10 WETH)
    function faucet(uint256 amount) external {
        require(
            amount <= 10 * 10 ** DECIMALS,
            "MockWETH: Max 10 WETH per faucet"
        );
        _mint(msg.sender, amount);
    }

    /// @notice Deposit ETH and get WETH (like real WETH)
    function deposit() external payable {
        _mint(msg.sender, msg.value);
    }

    /// @notice Withdraw WETH and get ETH (like real WETH)
    function withdraw(uint256 amount) external {
        require(
            balanceOf(msg.sender) >= amount,
            "MockWETH: Insufficient balance"
        );
        _burn(msg.sender, amount);
        payable(msg.sender).transfer(amount);
    }

    /// @notice Fallback to deposit ETH
    receive() external payable {
        _mint(msg.sender, msg.value);
    }
}


mockusdc:

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

/// @title Mock USDC Token
/// @notice Mock USDC token for testing and Flow deployment
/// @dev Mimics the real USDC token with 6 decimals
contract MockUSDC is ERC20, Ownable {
    uint8 private constant DECIMALS = 6;
    uint256 private constant INITIAL_SUPPLY = 1_000_000_000 * 10 ** DECIMALS; // 1B USDC

    constructor() ERC20("USD Coin", "USDC") Ownable(msg.sender) {
        _mint(msg.sender, INITIAL_SUPPLY);
    }

    function decimals() public pure override returns (uint8) {
        return DECIMALS;
    }

    /// @notice Mint new tokens (only owner)
    /// @param to Address to mint to
    /// @param amount Amount to mint
    function mint(address to, uint256 amount) external onlyOwner {
        _mint(to, amount);
    }

    /// @notice Burn tokens from caller
    /// @param amount Amount to burn
    function burn(uint256 amount) external {
        _burn(msg.sender, amount);
    }

    /// @notice Faucet function for testing (anyone can call)
    /// @param amount Amount to mint to caller (max 10,000 USDC)
    function faucet(uint256 amount) external {
        require(
            amount <= 10_000 * 10 ** DECIMALS,
            "MockUSDC: Max 10,000 USDC per faucet"
        );
        _mint(msg.sender, amount);
    }
}


mockerc20:

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

/// @title MockERC20
/// @notice Mock ERC20 token for testing purposes
contract MockERC20 is ERC20 {
    uint8 private _decimals;

    constructor(
        string memory name,
        string memory symbol,
        uint8 decimals_
    ) ERC20(name, symbol) {
        _decimals = decimals_;
    }

    function decimals() public view virtual override returns (uint8) {
        return _decimals;
    }

    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }

    function burn(address from, uint256 amount) external {
        _burn(from, amount);
    }
}


mockcontracts:

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract MockERC20 is ERC20 {
    constructor(string memory name, string memory symbol) ERC20(name, symbol) {}
    
    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
    
    function burn(address from, uint256 amount) external {
        _burn(from, amount);
    }
}

contract MockVault {
    address[] public strategies;
    mapping(address => bool) public isStrategy;
    
    function getStrategies() external view returns (address[] memory) {
        return strategies;
    }
    
    function depositToStrategy(address strategy, uint256 amount, bytes calldata data) external {
        // Mock implementation
    }
}

contract MockDeBridge {
    mapping(address => mapping(address => uint256)) public conversionRates;
    
    struct SwapParams {
        address tokenIn;
        address tokenOut;
        uint256 amountIn;
        uint256 minAmountOut;
        uint256 deadline;
        bytes extraData;
    }
    
    function setConversionRate(address tokenIn, address tokenOut, uint256 rate) external {
        conversionRates[tokenIn][tokenOut] = rate;
    }
    
    function getAmountOut(address tokenIn, address tokenOut, uint256 amountIn) external view returns (uint256) {
        uint256 rate = conversionRates[tokenIn][tokenOut];
        if (rate == 0) return amountIn; // 1:1 if no rate set
        return (amountIn * rate) / 1e18;
    }
    
    function swap(SwapParams calldata params) external returns (uint256) {
        uint256 rate = conversionRates[params.tokenIn][params.tokenOut];
        if (rate == 0) return params.amountIn; // 1:1 if no rate set
        return (params.amountIn * rate) / 1e18;
    }
    
    function send(
        address _tokenAddress,
        uint256 _amount,
        uint256 _chainIdTo,
        bytes memory _receiver,
        uint256 _permit,
        bool _useAssetFee,
        uint32 _referralCode,
        bytes calldata _autoParams
    ) external payable {
        // Mock implementation - just emit event or store data
    }
}

contract MockRoyaltyVault is ERC20 {
    mapping(address => mapping(address => uint256)) public claimableAmounts;
    
    constructor() ERC20("Mock Royalty Vault", "MRV") {}
    
    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
    
    function setClaimableAmount(address token, address claimer, uint256 amount) external {
        claimableAmounts[token][claimer] = amount;
    }
    
    function claimRevenueOnBehalfByTokenBatch(
        address claimer,
        address[] calldata tokens
    ) external returns (uint256[] memory) {
        uint256[] memory amounts = new uint256[](tokens.length);
        for (uint256 i = 0; i < tokens.length; i++) {
            amounts[i] = claimableAmounts[tokens[i]][claimer];
            // Transfer tokens to claimer (mock)
        }
        return amounts;
    }
}


contracts/interfaces:

vaults:
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";

/**
 * @title IVault
 * @dev Interface for the Vault contract that implements ERC4626 vault functionality
 * @notice This interface provides the standard methods for managing assets and strategies
 * @custom:security-contact security@vaults.com
 */
interface IVault is IERC20, IERC20Metadata {
    // ============ Events ============
    event StrategyAdded(address indexed strategy);
    event StrategyRemoved(address indexed strategy);
    event StrategyExecuted(address indexed strategy, bytes data);

    // ============ Errors ============
    error InvalidStrategy();
    error StrategyAlreadyExists();
    error StrategyDoesNotExist();
    error ExecutionFailed();
    error InvalidAddress();

    // ============ View Functions ============
    /**
     * @dev Returns the underlying asset of the vault
     * @return address The underlying asset address
     */
    function asset() external view returns (address);

    /**
     * @dev Returns the total assets managed by the vault
     * @return uint256 The total assets
     */
    function totalAssets() external view returns (uint256);

    /**
     * @dev Returns the list of strategies
     * @return address[] The list of strategies
     */
    function getStrategies() external view returns (address[] memory);

    /**
     * @dev Returns whether an address is a strategy
     * @param strategy The address to check
     * @return bool Whether the address is a strategy
     */
    function isStrategy(address strategy) external view returns (bool);

    /**
     * @dev Returns whether an address has the manager role
     * @param account The address to check
     * @return bool Whether the address has the manager role
     */
    function hasManagerRole(address account) external view returns (bool);

    /**
     * @dev Returns whether an address has the agent role
     * @param account The address to check
     * @return bool Whether the address has the agent role
     */
    function hasAgentRole(address account) external view returns (bool);

    // ============ State-Changing Functions ============
    /**
     * @dev Adds a new strategy to the vault
     * @param strategy The address of the strategy to add
     */
    function addStrategy(address strategy) external;

    /**
     * @dev Removes a strategy from the vault
     * @param strategy The address of the strategy to remove
     */
    function removeStrategy(address strategy) external;

    /**
     * @dev Executes a strategy with the given data
     * @param strategy The address of the strategy to execute
     * @param data The data to pass to the strategy
     */
    function executeStrategy(address strategy, bytes calldata data) external;

    /**
     * @dev Deposits assets to a strategy and executes it
     * @param strategy The address of the strategy to deposit to
     * @param amount The amount of assets to deposit
     * @param data Additional data for the strategy execution
     */
    function depositToStrategy(
        address strategy,
        uint256 amount,
        bytes calldata data
    ) external;

    /**
     * @dev Deposits assets into the vault
     * @param assets The amount of assets to deposit
     * @param receiver The address to receive the shares
     * @return uint256 The amount of shares minted
     */
    function deposit(
        uint256 assets,
        address receiver
    ) external returns (uint256);

    /**
     * @dev Mints shares for the receiver
     * @param shares The amount of shares to mint
     * @param receiver The address to receive the shares
     * @return uint256 The amount of assets deposited
     */
    function mint(uint256 shares, address receiver) external returns (uint256);

    /**
     * @dev Withdraws assets from the vault
     * @param assets The amount of assets to withdraw
     * @param receiver The address to receive the assets
     * @param owner The address that owns the shares
     * @return uint256 The amount of shares burned
     */
    function withdraw(
        uint256 assets,
        address receiver,
        address owner
    ) external returns (uint256);

    /**
     * @dev Redeems shares for assets
     * @param shares The amount of shares to redeem
     * @param receiver The address to receive the assets
     * @param owner The address that owns the shares
     * @return uint256 The amount of assets withdrawn
     */
    function redeem(
        uint256 shares,
        address receiver,
        address owner
    ) external returns (uint256);
}

strategies:
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

/**
 * @title IStrategies
 * @dev Interface for the Strategies contract that defines the core functionality for protocol interactions
 * @notice This interface provides the standard methods for interacting with various DeFi protocols
 * @custom:security-contact security@vaults.com
 */
interface IStrategies {
    // ============ Events ============
    event Deposit(uint256 amount);
    event Withdraw(uint256 amount);
    event Claim(uint256 amount);
    event VaultSet(address vault);
    event PausedState(bool isPaused);
    event Executed(uint256 amount, bytes data);
    event Harvested(bytes data);
    event EmergencyExited(uint256 balance, bytes data);
    event RewardTokenAdded(address indexed token);
    event TokensForwarded(address indexed token, uint256 amount);
    event ClaimRewardsFailed(bytes reason);

    // ============ Errors ============
    error NoVaultSet();
    error StrategyPaused();
    error DepositFailed(bytes reason);
    error WithdrawFailed(bytes reason);
    error ClaimFailed(bytes reason);
    error GetBalanceFailed(bytes reason);
    error NoUnderlyingBalance();
    error InvalidTokenAddress();
    error InvalidAmount();

    // ============ View Functions ============
    /**
     * @dev Returns the address of the underlying token
     * @return address The underlying token address
     */
    function underlyingToken() external view returns (address);

    /**
     * @dev Returns the address of the protocol
     * @return address The protocol address
     */
    function protocol() external view returns (address);

    /**
     * @dev Returns the deposit function selector
     * @return bytes4 The deposit function selector
     */
    function depositSelector() external view returns (bytes4);

    /**
     * @dev Returns the withdraw function selector
     * @return bytes4 The withdraw function selector
     */
    function withdrawSelector() external view returns (bytes4);

    /**
     * @dev Returns the claim function selector
     * @return bytes4 The claim function selector
     */
    function claimSelector() external view returns (bytes4);

    /**
     * @dev Returns the getBalance function selector
     * @return bytes4 The getBalance function selector
     */
    function getBalanceSelector() external view returns (bytes4);

    /**
     * @dev Returns the vault address
     * @return address The vault address
     */
    function vault() external view returns (address);

    /**
     * @dev Returns the paused state
     * @return bool The paused state
     */
    function paused() external view returns (bool);

    /**
     * @dev Returns whether a token is a known reward token
     * @param token The token address to check
     * @return bool Whether the token is a known reward token
     */
    function knownRewardTokens(address token) external view returns (bool);

    /**
     * @dev Returns the list of reward tokens
     * @return address[] The list of reward tokens
     */
    function rewardTokensList() external view returns (address[] memory);

    /**
     * @dev Gets the current balance of the strategy in the protocol
     * @return uint256 Balance of the strategy
     */
    function getBalance() external view returns (uint256);

    /**
     * @dev Query the protocol with custom parameters (read-only)
     * @param selector Function selector to call on the protocol
     * @param params Encoded parameters for the function call
     * @return bytes Raw response data from the protocol
     */
    function queryProtocol(
        bytes4 selector,
        bytes calldata params
    ) external view returns (bytes memory);

    // ============ State-Changing Functions ============
    /**
     * @dev Sets the vault address
     * @param _vault Address of the vault
     */
    function setVault(address _vault) external;

    /**
     * @dev Add a known reward token to track
     * @param tokenAddress Address of the reward token
     */
    function addRewardToken(address tokenAddress) external;

    /**
     * @dev Executes the strategy by depositing tokens into the protocol
     * @param amount Amount of tokens to deposit
     * @param data Additional data needed for the deposit
     */
    function execute(uint256 amount, bytes calldata data) external;

    /**
     * @dev Harvests rewards from the protocol
     * @param data Additional data needed for harvesting
     */
    function harvest(bytes calldata data) external;

    /**
     * @dev Performs an emergency exit, withdrawing all funds from the protocol
     * @param data Additional data needed for emergency exit
     */
    function emergencyExit(bytes calldata data) external;

    /**
     * @dev Claims rewards from the protocol
     * @param data Additional data needed for claiming rewards
     */
    function claimRewards(bytes calldata data) external;

    /**
     * @dev Sets the pause state
     * @param _paused New pause state
     */
    function setPaused(bool _paused) external;
}

ivaultfactory:
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

/// @title IVaultFactory Interface
/// @notice Interface for the VaultFactory contract
/// @dev Defines the core functionality for vault creation and management
interface IVaultFactory {
    // ============ Structs ============

    /// @notice Struct containing vault creation parameters
    struct VaultParams {
        IERC20 asset;
        string name;
        string symbol;
        address manager;
        address agent;
    }

    /// @notice Struct containing vault information
    struct VaultInfo {
        uint256 id;
        address vaultAddress;
        address asset;
        string name;
        string symbol;
        address manager;
        address agent;
        uint256 createdAt;
        address creator;
    }

    // ============ Events ============

    event VaultCreated(
        uint256 indexed vaultId,
        address indexed vaultAddress,
        address indexed asset,
        string name,
        string symbol,
        address manager,
        address agent,
        address creator
    );

    event DefaultManagerUpdated(
        address indexed oldManager,
        address indexed newManager
    );
    event DefaultAgentUpdated(
        address indexed oldAgent,
        address indexed newAgent
    );
    event CreationFeeUpdated(uint256 oldFee, uint256 newFee);
    event TreasuryUpdated(
        address indexed oldTreasury,
        address indexed newTreasury
    );
    event FeesWithdrawn(address indexed to, uint256 amount);

    // ============ Errors ============

    error InvalidAsset();
    error InvalidManager();
    error InvalidAgent();
    error InvalidTreasury();
    error EmptyName();
    error EmptySymbol();
    error InsufficientFee();
    error VaultNotFromFactory();
    error WithdrawalFailed();

    // ============ External Functions ============

    /// @notice Creates a new vault with specified parameters
    /// @param params Vault creation parameters
    /// @return vaultAddress Address of the created vault
    /// @return vaultId ID of the created vault
    function createVault(
        VaultParams calldata params
    ) external payable returns (address vaultAddress, uint256 vaultId);

    /// @notice Creates a vault with default manager and agent
    /// @param asset The underlying asset for the vault
    /// @param name Name of the vault token
    /// @param symbol Symbol of the vault token
    /// @return vaultAddress Address of the created vault
    /// @return vaultId ID of the created vault
    function createVaultWithDefaults(
        IERC20 asset,
        string calldata name,
        string calldata symbol
    ) external payable returns (address vaultAddress, uint256 vaultId);

    // ============ Admin Functions ============

    /// @notice Updates the default manager address
    /// @param _newDefaultManager New default manager address
    function setDefaultManager(address _newDefaultManager) external;

    /// @notice Updates the default agent address
    /// @param _newDefaultAgent New default agent address
    function setDefaultAgent(address _newDefaultAgent) external;

    /// @notice Updates the creation fee
    /// @param _newCreationFee New creation fee amount
    function setCreationFee(uint256 _newCreationFee) external;

    /// @notice Updates the treasury address
    /// @param _newTreasury New treasury address
    function setTreasury(address _newTreasury) external;

    /// @notice Withdraws accumulated fees to treasury
    function withdrawFees() external;

    // ============ View Functions ============

    /// @notice Returns the total number of vaults created
    /// @return count Total vault count
    function getVaultCount() external view returns (uint256 count);

    /// @notice Returns all vault addresses
    /// @return vaultAddresses Array of all vault addresses
    function getAllVaults()
        external
        view
        returns (address[] memory vaultAddresses);

    /// @notice Returns vault addresses for a specific asset
    /// @param asset Asset address
    /// @return vaultAddresses Array of vault addresses for the asset
    function getVaultsForAsset(
        address asset
    ) external view returns (address[] memory vaultAddresses);

    /// @notice Returns detailed information about a vault
    /// @param vaultId ID of the vault
    /// @return info Vault information struct
    function getVaultInfo(
        uint256 vaultId
    ) external view returns (VaultInfo memory info);

    /// @notice Returns vault information by vault address
    /// @param vaultAddress Address of the vault
    /// @return info Vault information struct
    function getVaultInfoByAddress(
        address vaultAddress
    ) external view returns (VaultInfo memory info);

    /// @notice Checks if a vault address was created by this factory
    /// @param vaultAddress Address to check
    /// @return isFromFactory True if vault was created by this factory
    function isVaultCreatedByFactory(
        address vaultAddress
    ) external view returns (bool isFromFactory);

    // ============ State Variable Getters ============

    /// @notice Returns the vault counter
    /// @return count Current vault counter
    function vaultCounter() external view returns (uint256 count);

    /// @notice Returns vault address by ID
    /// @param vaultId Vault ID
    /// @return vaultAddress Address of the vault
    function vaults(
        uint256 vaultId
    ) external view returns (address vaultAddress);

    /// @notice Returns vault ID by address
    /// @param vaultAddress Vault address
    /// @return vaultId ID of the vault
    function vaultIds(
        address vaultAddress
    ) external view returns (uint256 vaultId);

    /// @notice Returns the default manager address
    /// @return manager Default manager address
    function defaultManager() external view returns (address manager);

    /// @notice Returns the default agent address
    /// @return agent Default agent address
    function defaultAgent() external view returns (address agent);

    /// @notice Returns the creation fee
    /// @return fee Creation fee in wei
    function creationFee() external view returns (uint256 fee);

    /// @notice Returns the treasury address
    /// @return treasury Treasury address
    function treasury() external view returns (address treasury);
}

imultitokenvault:


// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

/// @title IMultiTokenVault
/// @notice Interface for a multi-token vault that supports ETH and various ERC20 tokens
/// @dev This interface extends basic vault functionality to support multiple asset types
interface IMultiTokenVault {
    // ============ Structs ============

    /// @notice Information about a supported token
    struct TokenInfo {
        address tokenAddress;
        bytes32 pythPriceId;
        uint8 decimals;
        bool isActive;
        uint256 totalDeposited;
    }

    /// @notice Deposit information for tracking user balances
    struct UserDeposit {
        address token;
        uint256 amount;
        uint256 usdValue;
        uint256 timestamp;
    }

    // ============ Events ============

    event TokenAdded(address indexed token, bytes32 priceId, uint8 decimals);
    event TokenRemoved(address indexed token);
    event TokenDeposited(
        address indexed user,
        address indexed token,
        uint256 amount,
        uint256 usdValue
    );
    event TokenWithdrawn(
        address indexed user,
        address indexed token,
        uint256 amount,
        uint256 usdValue
    );
    event ETHDeposited(address indexed user, uint256 amount, uint256 usdValue);
    event ETHWithdrawn(address indexed user, uint256 amount, uint256 usdValue);
    event PriceOracleUpdated(address indexed newOracle);

    // ============ Functions ============

    /// @notice Deposits ETH into the vault
    /// @dev Payable function that accepts ETH deposits
    function depositETH() external payable;

    /// @notice Deposits ERC20 tokens into the vault
    /// @param token The address of the token to deposit
    /// @param amount The amount of tokens to deposit
    function depositToken(address token, uint256 amount) external payable;

    /// @notice Withdraws ETH from the vault
    /// @param amount The amount of ETH to withdraw
    function withdrawETH(uint256 amount) external;

    /// @notice Withdraws ERC20 tokens from the vault
    /// @param token The address of the token to withdraw
    /// @param amount The amount of tokens to withdraw
    function withdrawToken(address token, uint256 amount) external;

    /// @notice Adds a new supported token to the vault
    /// @param token The address of the token to add
    /// @param pythPriceId The Pyth price ID for the token
    /// @param decimals The number of decimals for the token
    function addSupportedToken(
        address token,
        bytes32 pythPriceId,
        uint8 decimals
    ) external;

    /// @notice Removes a token from supported tokens
    /// @param token The address of the token to remove
    function removeSupportedToken(address token) external;

    /// @notice Sets the price oracle address
    /// @param oracle The address of the new price oracle
    function setPriceOracle(address oracle) external;

    /// @notice Gets the total USD value of all assets in the vault
    /// @return totalValue The total USD value
    function getTotalVaultValueUSD() external view returns (uint256 totalValue);

    /// @notice Gets the total USD value of a user's deposits
    /// @param user The address of the user
    /// @return totalValue The total USD value of user's deposits
    function getUserTotalValueUSD(
        address user
    ) external view returns (uint256 totalValue);

    /// @notice Gets user's balance for a specific token
    /// @param user The address of the user
    /// @param token The address of the token
    /// @return balance The user's balance for the token
    function getUserTokenBalance(
        address user,
        address token
    ) external view returns (uint256 balance);

    /// @notice Gets user's ETH balance
    /// @param user The address of the user
    /// @return balance The user's ETH balance
    function getUserETHBalance(
        address user
    ) external view returns (uint256 balance);

    /// @notice Gets information about a supported token
    /// @param token The address of the token
    /// @return info The token information
    function getTokenInfo(
        address token
    ) external view returns (TokenInfo memory info);

    /// @notice Gets all supported tokens
    /// @return tokens Array of supported token addresses
    function getSupportedTokens()
        external
        view
        returns (address[] memory tokens);

    /// @notice Checks if a token is supported
    /// @param token The address of the token to check
    /// @return isSupported Whether the token is supported
    function isTokenSupported(
        address token
    ) external view returns (bool isSupported);
}
